//---------- Legendre coefficients -> Gram Schmidt coefficients code --------------//

	//regular legendre integer coeffs without norm and multiplied by 2^n to make them integer
	vector< vector<long> >LegendreIntegerCoefficients;
	vector<long> element; element.push_back(1);
	LegendreIntegerCoefficients.push_back(element);
	element[0]=0; element.push_back(2); LegendreIntegerCoefficients.push_back(element);
	for(int i=2; i<totalNumOfBasisFn; i++)
		{
		vector<long> thevec; thevec.resize(i+1);
		for(int j=0; j<=i; j++)
			{
			thevec[j]=0;
			if(j<=i-2) thevec[j]+=-4*(i-1)*LegendreIntegerCoefficients[i-2][j];
			if(j>0) thevec[j]+=2*(2*i-1)*LegendreIntegerCoefficients[i-1][j-1];
			thevec[j]=thevec[j]/i;
			}
		LegendreIntegerCoefficients.push_back(thevec);
		}
		
	//shift these coefficients and remove 2^n factor
	double var1=2./bounds.slotWidth(); double var2=-(bounds.getLowerBound()+bounds.getUpperBound())/bounds.slotWidth(); long aux;
	for(int i=0; i<totalNumOfBasisFn; i++)
		{
		for(int p=0; p<=i; p++)
			{
			double sum=0; long currentBinomial=1;
			for(int j=p; j<=i; j++)
				{
				aux=currentBinomial*LegendreIntegerCoefficients[i][j];
				sum+=aux*pow(var2,j-p)*pow(var1,p);
				currentBinomial*=j+1; currentBinomial=currentBinomial/(j-p+1);
				}
			GramSchmidtCoeffs[i][p]=sum;
			}
		}

	//normalise properly
	double width=bounds.slotWidth();
	for(int i=0; i<totalNumOfBasisFn; i++) for(int j=0; j<=i; j++) GramSchmidtCoeffs[i][j]*=sqrt(2*i+1)/pow(sqrt(width),2*i+1)/pow(2,i); 
	
	//--------- Gram-Schmidt implementation for Taylor -------//
	
	void taylorSlot::initializeGramSchmidt()
	{
		//recursive legendre
		double sumbounds=bounds.getLowerBound()+bounds.getUpperBound(); double coeff1, coeff2, coeff3;
		for(int i=1; i<totalNumOfBasisFn; i++)
		{
			for(int j=0; j<=i; j++)
			{
				if(j>0) coeff1=2*GramSchmidtCoeffs[i-1][j-1];
				else coeff1=0;
				coeff2=sumbounds*GramSchmidtCoeffs[i-1][j];
				if(i>1) coeff3=GramSchmidtCoeffs[i-2][j]*(i-1);
				else coeff3=0;
				GramSchmidtCoeffs[i][j]= ( (2*i-1)*( coeff1 - coeff2 ) - coeff3 ) /double(i);
			}
		}
		
		double width=bounds.slotWidth();
		for(int i=0; i<totalNumOfBasisFn; i++) for(int j=0; j<=i; j++) GramSchmidtCoeffs[i][j]*=sqrt(2*i+1)/pow(sqrt(width),2*i+1);
		
	}

//--------- alternative Gram-Schmidt implementation -------//
	
		for(int i=0; i<totalNumOfBasisFn; i++)
		{
		double newnorm;
		for(int k=0; k<i; k++)
			{
			newnorm=0;
			for(int j1=0; j1<=i; j1++)
			    for(int j2=0; j2<=k; j2++)
				{
				newnorm+=GramSchmidtCoeffs[i][j1]*GramSchmidtCoeffs[k][j2]*pairwiseIntegral(j1,j2);
				}
			for(int j2=0; j2<=k; j2++) GramSchmidtCoeffs[i][j2]-=newnorm*GramSchmidtCoeffs[k][j2];
			}
			//can repeat this loop, but didn't improve things for me
		
		newnorm=0;
		for(int j1=0; j1<=i; j1++)
		    for(int j2=0; j2<=i; j2++)
			{
			newnorm+=GramSchmidtCoeffs[i][j1]*GramSchmidtCoeffs[i][j2]*pairwiseIntegral(j1,j2);
			}
		if(newnorm<=0) {cout << "ERROR: negative norm in Gram-Schmidt initialization in function number " << i << endl; printSlotInfo(); exit(EXIT_FAILURE);}
		newnorm=sqrt(newnorm);

		for(int j1=0; j1<=i; j1++) GramSchmidtCoeffs[i][j1]=GramSchmidtCoeffs[i][j1]/newnorm;
		}
		
//--------------- spline procedure with overlapping bins on each hierarchy level -----------------------//

splineArray histogramBasis::splineProcedureOverlap(unsigned int splineOrder, long norm, double fitAcceptanceThreshold)
	{
	unsigned int numberElementaryBins = basisSlots.size();
	unsigned int maxLevel=rounding(log(double(numberElementaryBins))/log(2));
	unsigned int currentLevel=2;
	
	//only works for 2^n elementary bins!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//make a bin hierarchy in advance by combining bins; position in vector denotes bin level: 0 is largest bin, 1 are second level bins etc
	//intervals can be marked in the same way: as a sequence 0 or 11 or 221 or 2331 etc
	vector< vector<basisSlot*> > analysisBins;
	vector<basisSlot*> currentLevelBins;
	for(unsigned int i=0;i<numberElementaryBins;i++) {basisSlots[i] -> updateEnoughSampled(); currentLevelBins.push_back(basisSlots[i] -> Clone());}
	for(unsigned int j=0;j<=maxLevel;j++)
		{
		analysisBins.insert(analysisBins.begin(),currentLevelBins);
		unsigned int currentSize = currentLevelBins.size();
		if(currentSize==1) break;
		currentLevelBins.resize(0);
		unsigned int next=2;
		if(j==0) next=1;
		for(unsigned int i=0;i<currentSize-next;i+=next)
			{
			slotBounds theBounds((analysisBins[0][i] -> getBounds()).getLowerBound(), (analysisBins[0][i+next] -> getBounds()).getUpperBound());
			basisSlot * combined = new basisSlot(theBounds);
			combined -> combineWithSlot(analysisBins[0][i]);
			combined -> combineWithSlot(analysisBins[0][i+next]);
			combined -> updateEnoughSampled();
			currentLevelBins.push_back(combined);
			}
		}
	
	for(unsigned int j=0;j<=maxLevel;j++)
		for(unsigned int i=0;i<analysisBins[j].size();i++)
			{
			analysisBins[j][i] -> scale(norm);
			}
		
	vector<slotBounds> intervalBounds;
	vector<unsigned int> intervalOrders;
	vector<unsigned int> intervalNumbers;
	slotBounds histogramBounds(lowerBound,upperBound);
	intervalBounds.push_back(histogramBounds);
	unsigned int currentNumberIntervals;
	intervalOrders.push_back(0); intervalNumbers.push_back(0);
	vector< vector<basisSlot*> > currentAnalysisBins;	//the bins on each given level don't have to be in order, only analysisBins do
	for(unsigned int j=0;j<=maxLevel;j++) currentAnalysisBins.push_back(analysisBins[j]);
	
	//divide bins by a level and check if intervals need to be split
	while(currentLevel<maxLevel)
		{
		//check matched spline
		splineArray result = matchedSplineFitOverlap(currentAnalysisBins, intervalBounds, splineOrder);	//we don't need errors, coefficients etc until the final spline -> refactor this!!!!!!!!!!!!
		
		//check if all fits good: now have multiple chi^2 contributions, should redefine isSplineGood function for this
		currentNumberIntervals=intervalBounds.size();
		bool isIntervalGood[currentNumberIntervals];
		bool allSplinesGood=true;
		for(unsigned int i=0;i<currentNumberIntervals;i++)
			{
			cout << "Checking interval " << i << " (order: " << intervalOrders[i] << ", number: " << intervalNumbers[i] << ")" << endl;
			spline * currentSpline = result.getSpline(i);
			bool currentSplineGood=true;
			for(unsigned int j=0;j<=maxLevel-intervalOrders[i];j++)
				{
				//test all bins fully within spline order by order
				double currentChisq=0;
				unsigned int numberSlotsAtCurrentLevel=analysisBins[intervalOrders[i]+j].size();
				for(unsigned int k=0;k<analysisBins[intervalOrders[i]+j].size();k++)
					{
					basisSlot* currentSlot = analysisBins[intervalOrders[i]+j][k];
					if( (currentSlot -> enoughSampled()) && (currentSlot->getBounds().getLowerBound()>=intervalBounds[i].getLowerBound()) && (currentSlot->getBounds().getUpperBound()<=intervalBounds[i].getUpperBound()) )
						{
						double currentSplineIntegral = currentSpline -> splineIntegral(currentSlot -> getBounds());
						currentSplineIntegral-=currentSlot -> sampledIntegral();
						currentSplineIntegral*=1./(currentSlot -> sampledIntegralError());
						currentChisq+=currentSplineIntegral*currentSplineIntegral;
						}
					else numberSlotsAtCurrentLevel--;
					}
				if(numberSlotsAtCurrentLevel>pow(2,j)/2.)
					{
					currentChisq*=1./double(numberSlotsAtCurrentLevel);
					cout << intervalOrders[i]+j << '\t' << numberSlotsAtCurrentLevel << '\t' << currentChisq << '\t' << 1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel)) << endl;
					if(currentChisq>1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))) {currentSplineGood=false; allSplinesGood=false; break;}
					}
				else {cout << "Only " << numberSlotsAtCurrentLevel << " good bins, not enough for evaluation" << endl; break;}	//already not enough data in slots at this level, so can stop checking
				}
			
			isIntervalGood[i]=currentSplineGood;
			cout << "This interval fit is "; if(!currentSplineGood) cout << "not "; cout << "good" << endl;
			}
		
		unsigned int intervalCounter=0;
		for(unsigned int i=0;i<currentNumberIntervals;i++)
			{
			if(!isIntervalGood[i])
				{
				intervalOrders[intervalCounter]++;
				intervalOrders.insert(intervalOrders.begin()+intervalCounter+1,intervalOrders[intervalCounter]);
				intervalNumbers[intervalCounter]*=2;
				intervalNumbers.insert(intervalNumbers.begin()+intervalCounter+1,intervalNumbers[intervalCounter]+1);
				intervalCounter++;
				}
			intervalCounter++;
			}
		
		intervalBounds.resize(0);
		for(unsigned int i=0;i<intervalOrders.size();i++)
			{
			slotBounds currentBounds = analysisBins[intervalOrders[i]][2*intervalNumbers[i]] -> getBounds();
			intervalBounds.push_back(currentBounds);
			}
		
		if(allSplinesGood) {cout << "Good spline found!" << endl; cout << endl; break;}
		currentLevel++;
		cout << endl;
		}
	
	splineArray result = matchedSplineFitOverlap(currentAnalysisBins, intervalBounds, splineOrder);
	return result;
}

		
splineArray matchedSplineFitOverlap(vector< vector<basisSlot*> > currentAnalysisBins, vector< slotBounds > intervalBounds, unsigned int splineOrder)
	{
	unsigned int numberIntervals=intervalBounds.size()-1;
	unsigned int matrixRows = 0;
	for(unsigned int i=0;i<currentAnalysisBins.size();i++) matrixRows+=currentAnalysisBins[i].size();
	unsigned int matrixCols=numberIntervals+splineOrder;
			
	//this vector (size = number intervals) stores for each interval the bins that are fully inside the interval -> for chi^2 on interval evaluation
	vector< vector<unsigned int> > binsFullyInsideInterval(numberIntervals+1);
			
	gsl_matrix * fullDesignMatrix = gsl_matrix_calloc (matrixRows, matrixCols);
	double* b = integralVector(currentAnalysisBins);
	gsl_vector * gslb= gsl_vector_calloc (matrixRows);
	for(unsigned int i=0;i<matrixRows;i++) gsl_vector_set(gslb,i,b[i]);
			
	double* binVec=binomialVector(splineOrder);
	double intervalMatrix[numberIntervals][splineOrder-1];
	double lastIntervalMatrix[numberIntervals][splineOrder-1];
			
	double* basicDesignMatrix = designMatrix(currentAnalysisBins, splineOrder);
	double currentLowerBound=0; double currentUpperBound; vector<basisSlot*>:: iterator it;
	for(unsigned int i=0;i<numberIntervals;i++)
		{
		currentUpperBound = intervalBounds[i].getUpperBound();
				
		for(unsigned int k=0; k < splineOrder-1;k++)
			{
			intervalMatrix[i][k]=(pow(currentUpperBound,splineOrder-1-k)-pow(currentLowerBound,splineOrder-1-k))*binVec[k]*pow(-1,splineOrder-2-k);
			lastIntervalMatrix[i][k]=-pow(currentUpperBound,splineOrder-1-k)*binVec[k]*pow(-1,splineOrder-2-k);
			}
				
		currentLowerBound=currentUpperBound;
		}
			
	//go through all bins after intervals
	unsigned int currentMatrixRow=0;
	for(unsigned int j1=0;j1 < currentAnalysisBins.size();j1++)
		for(unsigned int j2=0;j2 < currentAnalysisBins[j1].size();j2++)
			{
			slotBounds currentBounds=(currentAnalysisBins[j1][j2] -> getBounds());
			double currentError=currentAnalysisBins[j1][j2] -> sampledIntegralError();
			unsigned int start; unsigned int end;
			for(unsigned int i=0;i<=numberIntervals;i++)
				{
				if(currentBounds.overlapping(intervalBounds[i])) {start=i; break;}
				}
			for(unsigned int i=start;i<=numberIntervals;i++)
				{
				if(currentBounds.overlapping(intervalBounds[i])) {end=i;}
				}
					
			slotBounds startBounds(max(intervalBounds[start].getLowerBound(), currentBounds.getLowerBound()), intervalBounds[start].getUpperBound());
			slotBounds endBounds(intervalBounds[end].getLowerBound(), min(intervalBounds[end].getUpperBound(), currentBounds.getUpperBound()));
					
			//regular elements for a0, a1, a2
			for(unsigned int k=0; k < splineOrder-1;k++)
				gsl_matrix_set(fullDesignMatrix,currentMatrixRow,k,basicDesignMatrix[currentMatrixRow*splineOrder+k]);
					
			//very last element (x_i+1^4-x_i^4)/4
			if(start==end)
				{
				gsl_matrix_set(fullDesignMatrix,currentMatrixRow,start+splineOrder-1,basicDesignMatrix[currentMatrixRow*splineOrder+splineOrder-1]);
				binsFullyInsideInterval[start].push_back(currentMatrixRow);
				}
			else
				{
				for(unsigned int i=start;i<=end;i++)
					{
					slotBounds adjustedBounds=intervalBounds[i];
					if(i==start) adjustedBounds=startBounds;
					else if(i==end) adjustedBounds=endBounds;
					
					if( currentError < VERY_SMALL_NUMBER) gsl_matrix_set(fullDesignMatrix,currentMatrixRow,i+splineOrder-1,0);
					else gsl_matrix_set(fullDesignMatrix,currentMatrixRow,i+splineOrder-1, splineBasisFunction(adjustedBounds,splineOrder-1)/currentError/sqrt(double(currentAnalysisBins[j1].size())));
					}
				}
					
			//other a3 contributions
			if((start==end)&&(start>0))
				{
				for(unsigned int kk=0; kk < splineOrder-1;kk++)
					{
					for(unsigned int k=0; k < start; k++)
						gsl_matrix_set(fullDesignMatrix, currentMatrixRow, k+splineOrder-1, gsl_matrix_get(fullDesignMatrix,currentMatrixRow,k+splineOrder-1)+intervalMatrix[k][kk]*basicDesignMatrix[currentMatrixRow*splineOrder+kk]);
							
					gsl_matrix_set(fullDesignMatrix, currentMatrixRow, start+splineOrder-1, gsl_matrix_get(fullDesignMatrix,currentMatrixRow,start+splineOrder-1)+lastIntervalMatrix[start-1][kk]*basicDesignMatrix[currentMatrixRow*splineOrder+kk]);
					}
				}
			else if(start!=end)
				{
				bool adjust=true;
				if(start==0) {start++; adjust=false;}
				for(unsigned int i=start;i<=end;i++)
					{
					if( currentError > VERY_SMALL_NUMBER)
						{
						slotBounds adjustedBounds=intervalBounds[i];
						if( (i==start)  && adjust ) adjustedBounds=startBounds;
						else if(i==end) adjustedBounds=endBounds;
								
						for(unsigned int kk=0; kk < splineOrder-1;kk++)
							{
							for(unsigned int k=0; k < i; k++)
								gsl_matrix_set(fullDesignMatrix, currentMatrixRow, k+splineOrder-1, gsl_matrix_get(fullDesignMatrix,currentMatrixRow,k+splineOrder-1)+intervalMatrix[k][kk]*splineBasisFunction(adjustedBounds,kk)/currentError/sqrt(double(currentAnalysisBins[j1].size())));
									
							gsl_matrix_set(fullDesignMatrix, currentMatrixRow, i+splineOrder-1, gsl_matrix_get(fullDesignMatrix,currentMatrixRow,i+splineOrder-1)+lastIntervalMatrix[i-1][kk]*splineBasisFunction(adjustedBounds,kk)/currentError/sqrt(double(currentAnalysisBins[j1].size())));
							}
						}
					}
				}
					
			gsl_vector_set(gslb,currentMatrixRow,gsl_vector_get(gslb,currentMatrixRow));
			currentMatrixRow++;
			}
				
	gsl_matrix * V = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_vector * diagonal = gsl_vector_alloc (matrixCols);
	gsl_vector *x = gsl_vector_alloc (matrixCols);
				
	double totalChiSquared=solveSVD(fullDesignMatrix, V, gslb, diagonal, x);	//these need to be adjusted
	int totalDegreesOfFreedom=matrixRows-(numberIntervals+splineOrder-1);
	vector<spline*> splines;
				
	//this can actually be done in splineProcedure and probably should
	currentMatrixRow=0;
	cout << "Checking separate chi_n^2/n in spline fit" << endl;
	cout << "bin order" << '\t' << "n" << '\t' << "chi_n^2/n" << '\t' << "sqrt(2/n)" << endl;
	for(unsigned int j=0;j < currentAnalysisBins.size();j++)
		{
		int dof = currentAnalysisBins[j].size();
		gsl_vector_view currentgslb = gsl_vector_subvector (gslb, currentMatrixRow, dof);
		double chisq; gsl_blas_ddot (&currentgslb.vector, &currentgslb.vector, &chisq);
		cout << j << '\t' << dof << '\t' << chisq << '\t' << sqrt(2./double(dof)) << endl;
		currentMatrixRow+=dof;
		}
				
	double diagScaling[matrixCols];
	for(unsigned int j=0;j < matrixCols;j++) 
		{
		diagScaling[j]=0;
		if( gsl_vector_get(diagonal,j)>VERY_SMALL_NUMBER ) diagScaling[j]=1./gsl_vector_get(diagonal,j);
		}
				
	gsl_matrix * Vscaled = gsl_matrix_alloc (matrixCols, matrixCols);
	for (unsigned int i = 0; i < matrixCols; i++)
		for (unsigned int j = 0; j < matrixCols; j++)
			gsl_matrix_set(Vscaled,i,j,gsl_matrix_get(V,i,j)*diagScaling[j]);
					
	gsl_matrix * fullCovarianceMatrix = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_blas_dsyrk (CblasUpper, CblasNoTrans, 1, Vscaled, 0, fullCovarianceMatrix);
	double covarianceMatrix[matrixCols][matrixCols];
	for (unsigned int i = 0; i < matrixCols; i++)
		for (unsigned int j = 0; j < matrixCols; j++)
			covarianceMatrix[i][j]= gsl_matrix_get (fullCovarianceMatrix, i,j);
					
	vector<double> theCoefficients;
	for(unsigned int n=0;n<=numberIntervals;n++)
		{
		if(n==0) 
			{
			for(unsigned int i=0;i<splineOrder;i++) theCoefficients.push_back(gsl_vector_get(x,i));
			}
		else
			{
			for(unsigned int i=0;i<splineOrder-1;i++) theCoefficients[i]+=(gsl_vector_get(x,n+splineOrder-1)-theCoefficients[splineOrder-1])*lastIntervalMatrix[n-1][i];
			theCoefficients[splineOrder-1]=gsl_vector_get(x,n+splineOrder-1);
			}
					
		vector<double> theErrorCoefficients;
		for(unsigned int j=0;j < 2*splineOrder-1;j++) theErrorCoefficients.push_back(0); 
					
		if(n>0)
			{
			for(unsigned int j=0;j < splineOrder-1;j++)
				{
				for(unsigned int k=j;k < splineOrder-1;k++)
					{
					covarianceMatrix[j][k]+=(covarianceMatrix[j][splineOrder+n-1]-covarianceMatrix[j][splineOrder-1])*lastIntervalMatrix[n-1][k];
					covarianceMatrix[j][k]+=(covarianceMatrix[k][splineOrder+n-1]-covarianceMatrix[k][splineOrder-1])*lastIntervalMatrix[n-1][j];
					covarianceMatrix[j][k]+=(covarianceMatrix[splineOrder-1][splineOrder-1] + covarianceMatrix[splineOrder+n-1][splineOrder+n-1] - 2*covarianceMatrix[splineOrder+n-2][splineOrder+n-1])*lastIntervalMatrix[n-1][k]*lastIntervalMatrix[n-1][j];
					}
				covarianceMatrix[j][splineOrder-1]=covarianceMatrix[j][splineOrder+n-1];
				covarianceMatrix[j][splineOrder-1]+=(covarianceMatrix[splineOrder+n-1][splineOrder+n-1] - covarianceMatrix[splineOrder+n-2][splineOrder+n-1])*lastIntervalMatrix[n-1][j];
							
				for(unsigned int k=n;k < matrixCols-splineOrder;k++)
					covarianceMatrix[j][k+splineOrder]+=(covarianceMatrix[splineOrder+n-1][k+splineOrder] - covarianceMatrix[splineOrder+n-2][k+splineOrder])*lastIntervalMatrix[n-1][j];
				}
			covarianceMatrix[splineOrder-1][splineOrder-1]=covarianceMatrix[n+splineOrder-1][n+splineOrder-1];
			}
					
		for(unsigned int j=0;j < splineOrder;j++)
			for(unsigned int k=j;k < splineOrder;k++)
				{
				theErrorCoefficients[j+k]+=covarianceMatrix[j][k];
				if(j!=k) theErrorCoefficients[j+k]+=covarianceMatrix[j][k];
				}
						
		gsl_vector * currentgslb = gsl_vector_alloc (binsFullyInsideInterval[n].size());
		for(unsigned int j=0;j < binsFullyInsideInterval[n].size();j++) gsl_vector_set(currentgslb,j, gsl_vector_get(gslb,binsFullyInsideInterval[n][j]));
		double chisq; gsl_blas_ddot (currentgslb, currentgslb, &chisq);
		int dof = binsFullyInsideInterval[n].size();
					
		spline * solution = new spline(intervalBounds[n], splineOrder); solution -> setSpline(theCoefficients,theErrorCoefficients,chisq,dof);
		splines.push_back(solution);
		}
				
	splineArray result(splines);
	result.updateProperties(totalChiSquared,totalDegreesOfFreedom);
	return result;
				
	}
	
	
//----------------- spline procedure before improvements: exclude bad bins right away, overall check before interval checks --------------------//

splineArray histogramBasis::splineProcedure(unsigned int splineOrder, unsigned int minLevel, long norm, double fitAcceptanceThreshold, double gluingFactor)
{
	vector<double> a3array; vector<double> chisqArray;
	
	if(minLevel<2) minLevel=2;
	unsigned int numberElementaryBins = basisSlots.size();
	unsigned int maxLevel=rounding(log(double(numberElementaryBins))/log(2));
	unsigned int currentLevel=minLevel;
	
	//only works for 2^n elementary bins!
	//make a bin hierarchy in advance by combining bins; position in vector denotes bin level: 0 is largest bin, 1 are second level bins etc
	//intervals can be marked in the same way: as a sequence 0 or 11 or 221 or 2331 etc
	vector< vector<basisSlot*> > analysisBins;
	vector<basisSlot*> currentLevelBins;
	for(unsigned int i=0;i<numberElementaryBins;i++) {basisSlots[i] -> updateEnoughSampled(); currentLevelBins.push_back(basisSlots[i] -> Clone());}
	for(unsigned int j=0;j<=maxLevel;j++)
		{
		analysisBins.insert(analysisBins.begin(),currentLevelBins);
		unsigned int currentSize = currentLevelBins.size();
		if(currentSize==1) break;
		currentLevelBins.resize(0);
		for(unsigned int i=0;i<currentSize;i+=2)
			{
			slotBounds theBounds((analysisBins[0][i] -> getBounds()).getLowerBound(), (analysisBins[0][i+1] -> getBounds()).getUpperBound());
			basisSlot * combined = new basisSlot(theBounds);
			combined -> combineWithSlot(analysisBins[0][i]);
			combined -> combineWithSlot(analysisBins[0][i+1]);
			combined -> updateEnoughSampled();
			currentLevelBins.push_back(combined);
			}
		}
		
	for(unsigned int j=0;j<analysisBins.size();j++)
		for(unsigned int i=0;i<analysisBins[j].size();i++)
			{
			analysisBins[j][i] -> scale(norm);
			}
			
	//check whether data is consistent with zero everywhere
	if(isDataConsistentWithZero(analysisBins)==true) cout << "Data is consistent with zero on the interval" << endl;
		
	vector<slotBounds> intervalBounds;
	vector<unsigned int> intervalOrders;
	vector<unsigned int> intervalNumbers;
	slotBounds histogramBounds(lowerBound,upperBound);
	intervalBounds.push_back(histogramBounds);
	unsigned int currentNumberIntervals;
	intervalOrders.push_back(0); intervalNumbers.push_back(0);
	vector< vector<basisSlot*> > currentAnalysisBins;	//the bins on each given level don't have to be in order, only analysisBins do
	for(unsigned int j=0;j<=minLevel;j++) currentAnalysisBins.push_back(analysisBins[j]);
	
/*------------ Testing alternative setup when all bins are used ------------*/
for(unsigned int j=minLevel+1;j<=maxLevel;j++) currentAnalysisBins.push_back(analysisBins[j]);
/*------------ Testing alternative setup when all bins are used ------------*/
	
	//divide bins by a level and check if intervals need to be split
	//oneSplineFit should be special case of matchedSplineFit
	bool allSplinesGood;
	while(currentLevel<maxLevel)
		{
		//check matched spline
		splineArray result = matchedSplineFit(currentAnalysisBins, intervalBounds, splineOrder, 0, a3array, chisqArray);	//don't need errors, coefficients etc until the final spline -> refactor this!!!!!!!!
		
		//if(result.checkOverallAcceptance(fitAcceptanceThreshold)==true) allSplinesGood=true;
		//else {
		
		//check if all fits good: now have multiple chi^2 contributions, should redefine isSplineGood function for this
		currentNumberIntervals=intervalBounds.size();
		bool isIntervalGood[currentNumberIntervals];
		allSplinesGood=true;
		chisqArray.resize(0);
		for(unsigned int i=0;i<currentNumberIntervals;i++)
			{
			cout << "Checking interval " << i << " (order: " << intervalOrders[i] << ", number: " << intervalNumbers[i] << ")" << endl;
			spline * currentSpline = result.getSpline(i);
			bool currentSplineGood=true;
			chisqArray.push_back(1+fitAcceptanceThreshold*sqrt(2.));
			for(unsigned int j=0;j<=maxLevel-intervalOrders[i];j++)
				{
				//test all bins fully within spline order by order
				double currentChisq=0;
				unsigned int numberSlotsAtCurrentLevel = pow(2,j);
				for(unsigned int k=0;k<pow(2,j);k++)
					{
					basisSlot* currentSlot = analysisBins[intervalOrders[i]+j][intervalNumbers[i]*numberSlotsAtCurrentLevel+k];
					if(currentSlot -> enoughSampled())
						{
						double currentSplineIntegral = currentSpline -> splineIntegral(currentSlot -> getBounds());
						currentSplineIntegral-=currentSlot -> sampledIntegral();
						currentSplineIntegral*=1./(currentSlot -> sampledIntegralError());
						currentChisq+=currentSplineIntegral*currentSplineIntegral;
						}
					else numberSlotsAtCurrentLevel--;
					}
				if(numberSlotsAtCurrentLevel>pow(2,j)/2.)
					{
					currentChisq*=1./double(numberSlotsAtCurrentLevel);
					double delta=1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))-currentChisq; if(delta<0) delta=0;
					if(delta<chisqArray[i]) chisqArray[i]=delta;
					cout << intervalOrders[i]+j << '\t' << numberSlotsAtCurrentLevel << '\t' << currentChisq << '\t' << 1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel)) << endl;
					if(currentChisq>1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))) {currentSplineGood=false; allSplinesGood=false; break;}
					}
				else {cout << "Only " << numberSlotsAtCurrentLevel << " good bins, not enough for evaluation" << endl; break;}	//already not enough data in slots at this level, so can stop checking
				}
				
			isIntervalGood[i]=currentSplineGood;
			cout << "This interval fit is "; if(!currentSplineGood) cout << "not "; cout << "good" << endl;
			}
						
		unsigned int intervalCounter=0;
/*------------ Testing alternative setup when all bins are used ------------
		for(unsigned int i=0;i<currentNumberIntervals;i++)
			if(!isIntervalGood[i])
				{
				unsigned int nextOrder=intervalOrders[i]+minLevel+1;
				if(nextOrder<=maxLevel)
					{
					if(nextOrder==currentAnalysisBins.size()) {vector<basisSlot*> v; currentAnalysisBins.push_back(v);}
					for(unsigned int k=0;k<pow(2,minLevel+1);k++) currentAnalysisBins[nextOrder].push_back(analysisBins[nextOrder][pow(2,minLevel+1)*intervalNumbers[i]+k]);
					}
				}
------------ Testing alternative setup when all bins are used ------------*/
				
		for(unsigned int i=0;i<currentNumberIntervals;i++)
			{
			if(!isIntervalGood[i])
				{
				intervalOrders[intervalCounter]++;
				intervalOrders.insert(intervalOrders.begin()+intervalCounter+1,intervalOrders[intervalCounter]);
				intervalNumbers[intervalCounter]*=2;
				intervalNumbers.insert(intervalNumbers.begin()+intervalCounter+1,intervalNumbers[intervalCounter]+1);
				intervalCounter++;
				}
			intervalCounter++;
			}
			
		intervalBounds.resize(0);
		for(unsigned int i=0;i<intervalOrders.size();i++)
			{
			slotBounds currentBounds = analysisBins[intervalOrders[i]][intervalNumbers[i]] -> getBounds();
			intervalBounds.push_back(currentBounds);
			}

		//}
			
		if(allSplinesGood) {cout << "Good spline found!" << endl; cout << endl; break;}
		currentLevel++;
		cout << endl;
		}

if(!allSplinesGood) gluingFactor=0;
/**/if(gluingFactor>0)
	{
	a3array.resize(0);
	splineArray geta3=matchedSplineFit(currentAnalysisBins, intervalBounds, splineOrder, 0, a3array, chisqArray);
	for(unsigned int i=0;i<intervalOrders.size();i++) a3array.push_back((geta3.getSpline(i) -> getCoefficients())[splineOrder-1]);
	}
	
	splineArray result = matchedSplineFit(currentAnalysisBins, intervalBounds, splineOrder, gluingFactor, a3array, chisqArray);
	
/**/if(gluingFactor>0)
{
	cout << endl; cout << "Iterative consistent constraints procedure" << endl; cout << endl;
	for(int repeat=0;repeat<1;repeat++)
	{
	bool CCprocedureConverged=false; int iterations=0; double maximalGoodGluingFactor=0; double minimalBadGluingFactor=1/VERY_SMALL_NUMBER; int maxIterations=20;
	while(CCprocedureConverged==false)
		{
		iterations++;
		allSplinesGood=true;
		for(unsigned int i=0;i<intervalBounds.size();i++)
			{
			//cout << "Final check after CC; interval " << i << " (order: " << intervalOrders[i] << ", number: " << intervalNumbers[i] << ")" << endl;
			spline * currentSpline = result.getSpline(i);
			bool currentSplineGood=true;
			for(unsigned int j=0;j<=maxLevel-intervalOrders[i];j++)
				{
				//test all bins fully within spline order by order
				double currentChisq=0;
				unsigned int numberSlotsAtCurrentLevel = pow(2,j);
				for(unsigned int k=0;k<pow(2,j);k++)
					{
					basisSlot* currentSlot = analysisBins[intervalOrders[i]+j][intervalNumbers[i]*numberSlotsAtCurrentLevel+k];
					if(currentSlot -> enoughSampled())
						{
						double currentSplineIntegral = currentSpline -> splineIntegral(currentSlot -> getBounds());
						currentSplineIntegral-=currentSlot -> sampledIntegral();
						currentSplineIntegral*=1./(currentSlot -> sampledIntegralError());
						currentChisq+=currentSplineIntegral*currentSplineIntegral;
						}
					else numberSlotsAtCurrentLevel--;
					}
				if(numberSlotsAtCurrentLevel>pow(2,j)/2.)
					{
					currentChisq*=1./double(numberSlotsAtCurrentLevel);
					//cout << intervalOrders[i]+j << '\t' << numberSlotsAtCurrentLevel << '\t' << currentChisq << '\t' << 1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel)) << endl;
					if(currentChisq>1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))) {currentSplineGood=false; allSplinesGood=false; break;}
					}
				else {/*cout << "Only " << numberSlotsAtCurrentLevel << " good bins, not enough for evaluation" << endl;*/ break;}	//already not enough data in slots at this level, so can stop checking
				}
				
			//cout << "This interval fit is "; if(!currentSplineGood) cout << "not "; cout << "good" << endl;
			}
		cout << "Gluing factor " << gluingFactor << "; the spline is "; if(!allSplinesGood) cout << "not "; cout << "good" << endl;
		
		if(!allSplinesGood)
			{
			if(gluingFactor<minimalBadGluingFactor) minimalBadGluingFactor=gluingFactor;
			
			if(iterations>maxIterations) {gluingFactor=maximalGoodGluingFactor; CCprocedureConverged=true; allSplinesGood=true;}
			else if(maximalGoodGluingFactor>0) {gluingFactor=(maximalGoodGluingFactor+minimalBadGluingFactor)/2.;}
			else gluingFactor*=0.1;
			}
		else	{
			if(gluingFactor>maximalGoodGluingFactor) maximalGoodGluingFactor=gluingFactor;
			
			if(iterations>maxIterations) {CCprocedureConverged=true; gluingFactor=maximalGoodGluingFactor;}
			else if(minimalBadGluingFactor<1/VERY_SMALL_NUMBER) {gluingFactor=(maximalGoodGluingFactor+minimalBadGluingFactor)/2.;}
			else gluingFactor*=2;
			}
			
		result = matchedSplineFit(currentAnalysisBins, intervalBounds, splineOrder, gluingFactor, a3array, chisqArray);
		}
	/**/a3array.resize(0); chisqArray.resize(0);
	for(unsigned int i=0;i<intervalOrders.size();i++) a3array.push_back((result.getSpline(i) -> getCoefficients())[splineOrder-1]);
	for(unsigned int i=0;i<intervalBounds.size();i++)
		{
		spline * currentSpline = result.getSpline(i);
		chisqArray.push_back(1+fitAcceptanceThreshold*sqrt(2.));
		for(unsigned int j=0;j<=maxLevel-intervalOrders[i];j++)
			{
			//test all bins fully within spline order by order
			double currentChisq=0;
			unsigned int numberSlotsAtCurrentLevel = pow(2,j);
			for(unsigned int k=0;k<pow(2,j);k++)
				{
				basisSlot* currentSlot = analysisBins[intervalOrders[i]+j][intervalNumbers[i]*numberSlotsAtCurrentLevel+k];
				if(currentSlot -> enoughSampled())
					{
					double currentSplineIntegral = currentSpline -> splineIntegral(currentSlot -> getBounds());
					currentSplineIntegral-=currentSlot -> sampledIntegral();
					currentSplineIntegral*=1./(currentSlot -> sampledIntegralError());
					currentChisq+=currentSplineIntegral*currentSplineIntegral;
					}
				else numberSlotsAtCurrentLevel--;
				}
			if(numberSlotsAtCurrentLevel>pow(2,j)/2.)
				{
				currentChisq*=1./double(numberSlotsAtCurrentLevel);
				double delta=1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))-currentChisq; if(delta<0) delta=0;
				if(delta<chisqArray[i]) chisqArray[i]=delta;
				if(currentChisq>1+fitAcceptanceThreshold*sqrt(2./double(numberSlotsAtCurrentLevel))) {break;}
				}
			else break;
			}
		}/**/
	gluingFactor=1;
	}
}
/**/

	result.updateGoodness(allSplinesGood);
	return result;
}

//----------------- old spline procedures on small bins etc --------------------//

//header
spline oneSplineFit(unsigned int splineOrder = 4);
splineArray splineFit(std::vector<unsigned int> intervalBoundaries, double gluingFactor, unsigned int splineOrder = 4);
splineArray matchedSplineFitSmallBins(std::vector<unsigned int> intervalBoundaries, unsigned int splineOrder = 4);
splineArray splineProcedureSmallBins(unsigned int splineOrder, unsigned int minNumberBins, double fitAcceptanceThreshold);

//implementation

spline histogramBasis::oneSplineFit(unsigned int splineOrder)
{
	unsigned int dataSize = basisSlots.size();
	double* U = designMatrix(basisSlots, splineOrder);
	double* b = integralVector(basisSlots);
	gsl_matrix_view gslU = gsl_matrix_view_array (U, dataSize, splineOrder);
	gsl_vector_view gslb = gsl_vector_view_array (b, dataSize);
	
	gsl_matrix * V = gsl_matrix_alloc (splineOrder, splineOrder);
	gsl_vector * diagonal = gsl_vector_alloc (splineOrder);
	gsl_vector *x = gsl_vector_alloc (splineOrder);
	
	double chisq=solveSVD(&gslU.matrix, V, &gslb.vector, diagonal, x);
	
	vector<double> theCoefficients;
	for(unsigned int i=0;i<splineOrder;i++) theCoefficients.push_back(gsl_vector_get(x,i));
	
	double diagScaling[splineOrder];
	for(unsigned int j=0;j < splineOrder;j++) 
		{
		diagScaling[j]=0;
		if( gsl_vector_get(diagonal,j)>VERY_SMALL_NUMBER ) diagScaling[j]=1./(gsl_vector_get(diagonal,j)*gsl_vector_get(diagonal,j));
		}
		
	vector<double> theErrorCoefficients;
	for(unsigned int j=0;j < 2*splineOrder-1;j++) theErrorCoefficients.push_back(0);
		
	for(unsigned int j=0;j < splineOrder;j++)
		for(unsigned int k=j;k < splineOrder;k++)
			{
			double sum=0;
			for(unsigned int i=0;i<splineOrder;i++) sum+=diagScaling[i]*gsl_matrix_get(V,j,i)*gsl_matrix_get(V,k,i);
			theErrorCoefficients[j+k]+=sum;
			if(j!=k) theErrorCoefficients[j+k]+=sum;
			}
			
	int dof = dataSize-splineOrder;
	
	slotBounds theBounds(lowerBound,upperBound);
	spline solution(theBounds, splineOrder); solution.setSpline(theCoefficients,theErrorCoefficients,chisq,dof);
	return solution;
}

splineArray histogramBasis::splineFit(vector<unsigned int> intervalBoundaries, double gluingFactor, unsigned int splineOrder){
	//given boundaries, matching at knots approximate
	unsigned int numberIntervals=intervalBoundaries.size();
	unsigned int dataSize = basisSlots.size();
	int matrixRows=dataSize;
	if(gluingFactor>0) matrixRows+=(splineOrder-1)*numberIntervals;
	int matrixCols=(numberIntervals+1)*splineOrder;
	
	gsl_matrix * fullDesignMatrix = gsl_matrix_calloc (matrixRows, matrixCols);
	double* b = integralVector(basisSlots);
	gsl_vector * gslb= gsl_vector_calloc (matrixRows);
	for(unsigned int i=0;i<dataSize;i++) gsl_vector_set(gslb,i,b[i]);
	
	//regular part of block design matrix containing data integrals
	unsigned int start=0; unsigned int end;
	int rowOffset, colOffset;
	for(unsigned int i=0;i<=numberIntervals;i++)
		{			
		if(i!=numberIntervals) end = intervalBoundaries[i];
		else end = dataSize;
		rowOffset=start;
		colOffset=i*splineOrder;
		
		vector<basisSlot*> intervalSlots(basisSlots.begin() + start, basisSlots.begin() + end);
		double* U = designMatrix(intervalSlots, splineOrder);
	
		for(unsigned int j=0;j < end-start;j++)
			for(unsigned int k=0; k < splineOrder;k++)
				gsl_matrix_set(fullDesignMatrix,rowOffset+j,colOffset+k,U[j*splineOrder+k]);
	
		start=end;
		}
		
	//extra part of design matrix responsible for matching splines at boundaries up to second derivative
	if(gluingFactor>0)
		{
		rowOffset=dataSize;
		colOffset=0;
		double* binMat=binomialMatrix(splineOrder);
		double theBound;
		for(unsigned int i=0;i<numberIntervals;i++)
			{
			theBound=(basisSlots[intervalBoundaries[i]] -> getBounds()).getLowerBound();
			for(unsigned int j=0;j < splineOrder-1;j++)
				for(unsigned int k=j;k < splineOrder;k++)
					{
					double variable=pow(theBound,k-j);
					gsl_matrix_set(fullDesignMatrix, rowOffset+j, colOffset+k, gluingFactor*binMat[j*splineOrder+k]*variable);
					gsl_matrix_set(fullDesignMatrix, rowOffset+j, colOffset+splineOrder+k, -gluingFactor*binMat[j*splineOrder+k]*variable);
					}
			rowOffset+=splineOrder-1;
			colOffset+=splineOrder;
			}
		}
		
	gsl_matrix * V = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_vector * diagonal = gsl_vector_alloc (matrixCols);
	gsl_vector *x = gsl_vector_alloc (matrixCols);
	
	double totalChiSquared=solveSVD(fullDesignMatrix, V, gslb, diagonal, x);
	int totalDegreesOfFreedom=dataSize-4*(numberIntervals+1);
	vector<spline*> splines;
	
	double diagScaling[(numberIntervals+1)*splineOrder];
	for(unsigned int j=0;j < (numberIntervals+1)*splineOrder;j++) 
		{
		diagScaling[j]=0;
		if( gsl_vector_get(diagonal,j)>VERY_SMALL_NUMBER ) diagScaling[j]=1./gsl_vector_get(diagonal,j);
		}
		
	gsl_matrix * Vscaled = gsl_matrix_alloc (matrixCols, matrixCols);
	for (int i = 0; i < matrixCols; i++)
		for (int j = 0; j < matrixCols; j++) gsl_matrix_set(Vscaled,i,j,gsl_matrix_get(V,i,j)*diagScaling[j]);
	gsl_matrix * fullCovarianceMatrix = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_blas_dsyrk (CblasUpper, CblasNoTrans, 1, Vscaled, 0, fullCovarianceMatrix);
	
	start=0; double currentLowerBound; double currentUpperBound; vector<basisSlot*>:: iterator it;
	for(unsigned int n=0;n<=numberIntervals;n++)
		{
		if(n!=numberIntervals) end = intervalBoundaries[n];
		else end = dataSize;
		it=basisSlots.begin() + start;
		currentLowerBound = (it[0] -> getBounds()).getLowerBound();
		it=basisSlots.begin() + end - 1;
		currentUpperBound = (it[0] -> getBounds()).getUpperBound();
			
		vector<double> theCoefficients;
		for(unsigned int i=0;i<splineOrder;i++) theCoefficients.push_back(gsl_vector_get(x,n*splineOrder+i));
		
		vector<double> theErrorCoefficients;
		for(unsigned int j=0;j < 2*splineOrder-1;j++) theErrorCoefficients.push_back(0); 
		
		for(unsigned int j=0;j < splineOrder;j++)
			for(unsigned int k=j;k < splineOrder;k++)
				{
				theErrorCoefficients[j+k]+=gsl_matrix_get(fullCovarianceMatrix,n*splineOrder+j,n*splineOrder+k);
				if(j!=k) theErrorCoefficients[j+k]+=gsl_matrix_get(fullCovarianceMatrix,n*splineOrder+j,n*splineOrder+k);
				}

		gsl_vector_view currentgslb = gsl_vector_subvector (gslb, start, end-start);
		double chisq; gsl_blas_ddot (&currentgslb.vector, &currentgslb.vector, &chisq);
		int dof = end-start-splineOrder;
		
		slotBounds theBounds(currentLowerBound,currentUpperBound);
		spline * solution = new spline(theBounds, splineOrder); solution -> setSpline(theCoefficients,theErrorCoefficients,chisq,dof);
		splines.push_back(solution);
		
		start=end;
		}
		
	splineArray result(splines);
	result.updateProperties(totalChiSquared,totalDegreesOfFreedom);
	return result;
}

splineArray histogramBasis::matchedSplineFitSmallBins(std::vector< unsigned int > intervalBoundaries, unsigned int splineOrder)
{
	unsigned int numberIntervals=intervalBoundaries.size();
	unsigned int matrixRows = basisSlots.size();
	unsigned int matrixCols=numberIntervals+splineOrder;
	
	gsl_matrix * fullDesignMatrix = gsl_matrix_calloc (matrixRows, matrixCols);
	double* b = integralVector(basisSlots);
	gsl_vector * gslb= gsl_vector_calloc (matrixRows);
	for(unsigned int i=0;i<matrixRows;i++) gsl_vector_set(gslb,i,b[i]);
	
	double* binVec=binomialVector(splineOrder);
	double intervalMatrix[numberIntervals][splineOrder-1];
	double lastIntervalMatrix[numberIntervals][splineOrder-1];
	
	//design matrix
	double* basicDesignMatrix = designMatrix(basisSlots, splineOrder);
	unsigned int start=0; unsigned int end;
	double currentLowerBound=0; double currentUpperBound; vector<basisSlot*>:: iterator it;
	for(unsigned int i=0;i<=numberIntervals;i++)
		{
		if(i==numberIntervals) end = matrixRows;
		else
			{
			end = intervalBoundaries[i];
			it=basisSlots.begin() + end - 1;
			currentUpperBound = (it[0] -> getBounds()).getUpperBound();
		
			for(unsigned int k=0; k < splineOrder-1;k++)
				{
				intervalMatrix[i][k]=(pow(currentUpperBound,splineOrder-1-k)-pow(currentLowerBound,splineOrder-1-k))*binVec[k]*pow(-1,splineOrder-2-k);
				lastIntervalMatrix[i][k]=-pow(currentUpperBound,splineOrder-1-k)*binVec[k]*pow(-1,splineOrder-2-k);
				}
			}
			
		for(unsigned int j=0;j < end-start;j++)
			{
			for(unsigned int k=0; k < splineOrder-1;k++)
				gsl_matrix_set(fullDesignMatrix,start+j,k,basicDesignMatrix[(start+j)*splineOrder+k]);
			
			gsl_matrix_set(fullDesignMatrix,start+j,i+splineOrder-1,basicDesignMatrix[(start+j)*splineOrder+splineOrder-1]);
		
			if(i>0)
				{
				for(unsigned int kk=0; kk < splineOrder-1;kk++)
				    {
				    for(unsigned int k=0; k < i;k++)
					gsl_matrix_set(fullDesignMatrix, start+j, k+splineOrder-1, gsl_matrix_get(fullDesignMatrix,start+j,k+splineOrder-1)+intervalMatrix[k][kk]*basicDesignMatrix[(start+j)*splineOrder+kk]);
				    
				    gsl_matrix_set(fullDesignMatrix, start+j, i+splineOrder-1, gsl_matrix_get(fullDesignMatrix,start+j,i+splineOrder-1)+lastIntervalMatrix[i-1][kk]*basicDesignMatrix[(start+j)*splineOrder+kk]);
				    }
				}
			}
			
		currentLowerBound=currentUpperBound;
		start=end;
		}

	gsl_matrix * V = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_vector * diagonal = gsl_vector_alloc (matrixCols);
	gsl_vector *x = gsl_vector_alloc (matrixCols);
	
	double totalChiSquared=solveSVD(fullDesignMatrix, V, gslb, diagonal, x);
	int totalDegreesOfFreedom=matrixRows-(numberIntervals+splineOrder-1);
	vector<spline*> splines;
	
	double diagScaling[matrixCols];
	for(unsigned int j=0;j < matrixCols;j++) 
		{
		diagScaling[j]=0;
		if( gsl_vector_get(diagonal,j)>VERY_SMALL_NUMBER ) diagScaling[j]=1./gsl_vector_get(diagonal,j);
		}
	
	gsl_matrix * Vscaled = gsl_matrix_alloc (matrixCols, matrixCols);
	for (unsigned int i = 0; i < matrixCols; i++)
		for (unsigned int j = 0; j < matrixCols; j++)
			gsl_matrix_set(Vscaled,i,j,gsl_matrix_get(V,i,j)*diagScaling[j]);
	gsl_matrix * fullCovarianceMatrix = gsl_matrix_alloc (matrixCols, matrixCols);
	gsl_blas_dsyrk (CblasUpper, CblasNoTrans, 1, Vscaled, 0, fullCovarianceMatrix);
	double covarianceMatrix[matrixCols][matrixCols];
	for (unsigned int i = 0; i < matrixCols; i++)
		for (unsigned int j = 0; j < matrixCols; j++)
			covarianceMatrix[i][j]= gsl_matrix_get (fullCovarianceMatrix, i,j);
		
	start=0;
	vector<double> theCoefficients;
	for(unsigned int n=0;n<=numberIntervals;n++)
		{
		if(n!=numberIntervals) end = intervalBoundaries[n];
		else end = matrixRows;
		it=basisSlots.begin() + start;
		currentLowerBound = (it[0] -> getBounds()).getLowerBound();
		it=basisSlots.begin() + end - 1;
		currentUpperBound = (it[0] -> getBounds()).getUpperBound();
		
		if(n==0) 
			{
			for(unsigned int i=0;i<splineOrder;i++) theCoefficients.push_back(gsl_vector_get(x,i));
			}
		else
			{
			for(unsigned int i=0;i<splineOrder-1;i++) theCoefficients[i]+=(gsl_vector_get(x,n+splineOrder-1)-theCoefficients[splineOrder-1])*lastIntervalMatrix[n-1][i];
			theCoefficients[splineOrder-1]=gsl_vector_get(x,n+splineOrder-1);
			}
		
		vector<double> theErrorCoefficients;
		for(unsigned int j=0;j < 2*splineOrder-1;j++) theErrorCoefficients.push_back(0); 
		
		if(n>0)
			{
			for(unsigned int j=0;j < splineOrder-1;j++)
				{
				for(unsigned int k=j;k < splineOrder-1;k++)
					{
					covarianceMatrix[j][k]+=(covarianceMatrix[j][splineOrder+n-1]-covarianceMatrix[j][splineOrder-1])*lastIntervalMatrix[n-1][k];
					covarianceMatrix[j][k]+=(covarianceMatrix[k][splineOrder+n-1]-covarianceMatrix[k][splineOrder-1])*lastIntervalMatrix[n-1][j];
					covarianceMatrix[j][k]+=(covarianceMatrix[splineOrder-1][splineOrder-1] + covarianceMatrix[splineOrder+n-1][splineOrder+n-1] - 2*covarianceMatrix[splineOrder+n-2][splineOrder+n-1])*lastIntervalMatrix[n-1][k]*lastIntervalMatrix[n-1][j];
					}
				covarianceMatrix[j][splineOrder-1]=covarianceMatrix[j][splineOrder+n-1];
				covarianceMatrix[j][splineOrder-1]+=(covarianceMatrix[splineOrder+n-1][splineOrder+n-1] - covarianceMatrix[splineOrder+n-2][splineOrder+n-1])*lastIntervalMatrix[n-1][j];
			
				for(unsigned int k=n;k < matrixCols-splineOrder;k++)
					covarianceMatrix[j][k+splineOrder]+=(covarianceMatrix[splineOrder+n-1][k+splineOrder] - covarianceMatrix[splineOrder+n-2][k+splineOrder])*lastIntervalMatrix[n-1][j];
				}
			covarianceMatrix[splineOrder-1][splineOrder-1]=covarianceMatrix[n+splineOrder-1][n+splineOrder-1];
			}
		
		for(unsigned int j=0;j < splineOrder;j++)
			for(unsigned int k=j;k < splineOrder;k++)
			{
				theErrorCoefficients[j+k]+=covarianceMatrix[j][k];
				if(j!=k) theErrorCoefficients[j+k]+=covarianceMatrix[j][k];
			}
		
		gsl_vector_view currentgslb = gsl_vector_subvector (gslb, start, end-start);
		double chisq; gsl_blas_ddot (&currentgslb.vector, &currentgslb.vector, &chisq);
		int dof = end-start-splineOrder;
		//cout << theCoefficients[splineOrder-1] << '\t' << sqrt(covarianceMatrix[splineOrder-1][splineOrder-1]) << '\t' << chisq/double(dof) << endl;
		
		slotBounds theBounds(currentLowerBound,currentUpperBound);
		spline * solution = new spline(theBounds, splineOrder); solution -> setSpline(theCoefficients,theErrorCoefficients,chisq,dof);
		splines.push_back(solution);
		
		start=end;
		}
	
	/*------------- testing interval distribution ----------------------*/
// 	start=0; 
// 	//ofstream output("corrchisqratio.dat");
// 	for(unsigned int n=0;n<=numberIntervals;n++)
// 		{
// 		if(n!=numberIntervals) end = intervalBoundaries[n];
// 		else end = matrixRows;
// 		
// 		int cut=7;
// 		
// 		cout << "Interval " << n << endl; 
// 		for(int m=-cut;m<=cut;m++) if( (n+m>=0) && (n+m<=numberIntervals) ) cout << left << setw(20) << n+m << setw(2);
// 		cout << endl;
// 	
// 		gsl_matrix * currentDesignMatrix = gsl_matrix_alloc (end-start, splineOrder);
// 		gsl_vector * currentb= gsl_vector_alloc (end-start);
// 		gsl_vector * currentCoeffs=gsl_vector_alloc (splineOrder);
// 		for(unsigned int i=0;i<end-start;i++) 
// 			for(unsigned int j=0;j<splineOrder;j++)
// 				gsl_matrix_set(currentDesignMatrix,i,j,basicDesignMatrix[(start+i)*splineOrder+j]);
// 		double currentChisq;
// 		int dof = end-start-splineOrder;
// 
// 		for(int m=-cut;m<=cut;m++)
// 			{
// 			if( (n+m>=0) && (n+m<=numberIntervals) )
// 				{
// 				for(unsigned int j=0;j<splineOrder;j++) gsl_vector_set(currentCoeffs,j, (splines[n+m] -> getCoefficients())[j]);
// 				for(unsigned int i=0;i<end-start;i++) gsl_vector_set(currentb,i,b[start+i]);
// 				gsl_blas_dgemv (CblasNoTrans, 1, currentDesignMatrix, currentCoeffs, -1, currentb);
// 				gsl_blas_ddot (currentb, currentb, &currentChisq);
// 				cout << setw(10) << setprecision(2) << currentChisq << setw(10) << currentChisq/double(dof) << setw(2);
// 				/*
// 				if(m<0) {
// 					double variable=(splines[n+m] -> getBounds()).getLowerBound(); double curError=splines[n+m] -> splineError(variable); if(curError<VERY_SMALL_NUMBER) curError=1e-6;
// 					output << currentChisq/double(dof) << '\t' << abs(((splines[n]-> splineValue(variable)) - (splines[n+m]-> splineValue(variable)))/curError) << endl;
// 					}
// 				if(m>0) {
// 					double variable=(splines[n+m] -> getBounds()).getUpperBound();  double curError=splines[n+m] -> splineError(variable); if(curError<VERY_SMALL_NUMBER) curError=1e-6;
// 					output << currentChisq/double(dof) << '\t' << abs(((splines[n]-> splineValue(variable)) - (splines[n+m]-> splineValue(variable)))/curError) << endl;
// 					}
// 				*/
// 				}
// 			}
// 		cout << endl;
// 		
// 		for(int m=-cut;m<=cut;m++) if( (n+m>=0) && (n+m<=numberIntervals) ) cout << setw(20) << setprecision(4) << (splines[n+m] -> getBounds()).getLowerBound() << setw(2);
// 		if( n+cut<=numberIntervals ) cout << setw(20) << setprecision(4) << (splines[n+cut] -> getBounds()).getUpperBound() << setw(2);
// 		cout << endl; 
// 		for(int m=-cut;m<=cut;m++)
// 		    if( (n+m>=0) && (n+m<=numberIntervals) )
// 			{
// 				double variable=(splines[n+m] -> getBounds()).getLowerBound(); double curError=splines[n+m] -> splineError(variable); if(curError<VERY_SMALL_NUMBER) curError=1e-6;
// 		    cout << setw(20) << setprecision(8) << ((splines[n]-> splineValue(variable)) - (splines[n+m]-> splineValue(variable)))/curError << setw(2);
// 			}
// 		if( n+cut<=numberIntervals )
// 			{
// 			double variable=(splines[n+cut] -> getBounds()).getUpperBound();  double curError=splines[n+cut] -> splineError(variable); if(curError<VERY_SMALL_NUMBER) curError=1e-6;
// 			cout << setw(20) << setprecision(8) << ((splines[n]-> splineValue(variable)) - (splines[n+cut]-> splineValue(variable)))/curError << setw(2);
// 			}
// 		cout << endl; cout << endl;
// 		
// 		start=end;
// 		}
	
	/*------------------------------------------------------------------*/
	

	splineArray result(splines);
	result.updateProperties(totalChiSquared,totalDegreesOfFreedom);
	return result;
	
}


splineArray histogramBasis::splineProcedureSmallBins(unsigned int splineOrder, unsigned int minNumberBins, double fitAcceptanceThreshold)
{
	spline spline1 = oneSplineFit(splineOrder);
	
	if(spline1.isSplineGood(fitAcceptanceThreshold))
		{
		vector<spline*> splines;
		spline * solution = new spline(spline1.getBounds(), splineOrder);
		solution -> setSpline(spline1.getCoefficients(),spline1.getErrorCoefficients(),(spline1.getChisquared())*(spline1.getDOF()),spline1.getDOF());
		splines.push_back(solution);
		splineArray result(splines);
		result.updateProperties( (spline1.getChisquared())*(spline1.getDOF()),spline1.getDOF());

		return result;
		}
		
	else 	{
		if(minNumberBins<2*splineOrder) minNumberBins=2*splineOrder;
		bool finishedUpdating=false;
		unsigned int matrixRows = basisSlots.size();
		vector<unsigned int> intervalBoundaries;
		intervalBoundaries.push_back(matrixRows/2);
	
		while(finishedUpdating==false)
			{				
			splineArray result = matchedSplineFitSmallBins(intervalBoundaries, splineOrder);	//we don't need errors, coefficients etc until the final spline -> refactor this!!!!!!!!!!!!
			finishedUpdating=true;
		
			unsigned int originalSize=intervalBoundaries.size();
			unsigned int adjustedBoundaries=0;
		
			for(unsigned int i=0;i<=originalSize;i++)
				{
				bool currentSplineGood = result.getSpline(i) -> isSplineGood(fitAcceptanceThreshold);
				if(!currentSplineGood)
					{
					int start=0; if(i>0) start = intervalBoundaries[i+adjustedBoundaries-1];
					int end=matrixRows; if(i+adjustedBoundaries<intervalBoundaries.size()) end = intervalBoundaries[i+adjustedBoundaries];
					int delta = (end-start)/2;
					if(delta>=minNumberBins)
						{
						intervalBoundaries.insert(intervalBoundaries.begin()+i+adjustedBoundaries, start+delta);
						adjustedBoundaries++;
						finishedUpdating=false;
						} 
					}
				}
			if(finishedUpdating) return result;
			}
		}
}












